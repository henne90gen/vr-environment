#version 440 core

//***** begin interface of noice_lib.glsl ***********************************
const int MAX_NUM_NOISE_LAYERS = 15;
struct NoiseLayer {
    float frequency;
    float amplitude;
    bool enabled;
};
vec3 snoise2(vec2 P);
vec4 generateHeight(in vec2 pos, in NoiseLayer noiseLayers[MAX_NUM_NOISE_LAYERS], in int numNoiseLayers,
in bool useFiniteDifferences, in float finiteDifference, in float power, in float bowlStrength, in float platformHeight,
in int seed);
//***** end interface of noice_lib.glsl ***********************************

layout (triangles, equal_spacing, cw) in;

in vec2 position_tes[];
in vec3 ev_tes[];

uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform float uvScaleFactor;
uniform vec3 cameraPosition;

uniform NoiseLayer noiseLayers[MAX_NUM_NOISE_LAYERS];
uniform int numNoiseLayers;
uniform bool useFiniteDifferences;
uniform float finiteDifference;
uniform float power;
uniform float bowlStrength;
uniform float platformHeight;
uniform int seed;

out vec2 uv_fs;
out vec3 normal_fs;
out vec3 tangent_fs;
out vec3 bitangent_fs;
out vec3 model_position_fs;
out float normalized_height_fs;

void main() {
    vec2 pos = gl_TessCoord.x * position_tes[0];
    pos     += gl_TessCoord.y * position_tes[1];
    pos     += gl_TessCoord.z * position_tes[2];

    vec4 noise = generateHeight(pos, noiseLayers, numNoiseLayers, useFiniteDifferences, finiteDifference, power, bowlStrength, platformHeight, seed);
    normalized_height_fs = noise.w;
    tangent_fs = vec3(1.0F, noise.y, 0.0F);
    bitangent_fs = vec3(0.0F, noise.z, 1.0F);
    normal_fs = -normalize(cross(tangent_fs, bitangent_fs));

    vec4 position = viewMatrix * modelMatrix * vec4(pos.x, noise.x, pos.y, 1.0F);
    model_position_fs = position.xyz;
    gl_Position = projectionMatrix * position;

    uv_fs = pos / uvScaleFactor;
}
