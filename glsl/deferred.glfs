#version 460

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

//***** begin interface of scatter.glsl ***********************************
vec3 calculate_scattering(
vec3 start, // the start of the ray (the camera position)
vec3 dir, // the direction of the ray (the camera vector)
float max_dist, // the maximum distance the ray can travel (because something is in the way, like an object)

mat4 viewMatrix, // HACK we are using the camera orientation to position the planet correctly, since the given start position and direction are in camera space

vec3 scene_color, // the color of the scene
vec3 light_dir, // the direction of the light
vec3 light_intensity// how bright the light is, affects the brightness of the atmosphere
);
//***** end interface of scatter.glsl ***********************************

in vec2 texcoord_fs;

out vec4 color;

uniform sampler2D gPosition;
uniform sampler2D gNormal;
uniform sampler2D gAlbedo;
uniform sampler2D gIsCloud;

uniform int render_target = 0;
uniform bool use_atmospheric_scattering = false;
uniform float aspect_ratio = 1.0F;// TODO find out where we can get this information from

struct Light {
    vec3 FragmentToLightDir;
    vec3 Color;

    float Ambient;
    float Diffuse;
    float Specular;
};
uniform Light light;

void main() {
    if (render_target == 1) {
        color = texture(gPosition, texcoord_fs);
        return;
    }
    if (render_target == 2) {
        color = texture(gNormal, texcoord_fs);
        return;
    }
    if (render_target == 3) {
        color = texture(gAlbedo, texcoord_fs);
        return;
    }
    if (render_target == 4) {
        vec4 temp = texture(gIsCloud, texcoord_fs);
        color = vec4(temp.r, temp.r, temp.r, 1.0F);
        return;
    }

    vec3 FragPos = texture(gPosition, texcoord_fs).xyz;
    vec3 Normal = normalize(texture(gNormal, texcoord_fs).xyz);
    vec3 Diffuse = texture(gAlbedo, texcoord_fs).rgb;
    bool CloudLighting = texture(gIsCloud, texcoord_fs).r == 1.0F;

    if (FragPos.x == 0.0 && FragPos.y == 0.0 && FragPos.z == 0.0) {
        // position of the background, set this to something very far away
        vec2 uv = (texcoord_fs - vec2(0.5)) * 2.0;
        uv.x *= aspect_ratio;
        FragPos = normalize(vec3(uv, -1.0)) * 1e12;
    }

    color = vec4(Diffuse, 1.0F);

    if (use_atmospheric_scattering) {
        // TODO revisit atmospheric scattering open problems:
        //  light direction
        //  camera orientation

        if (CloudLighting) {
            vec2 uv = (texcoord_fs - vec2(0.5)) * 2.0;
            uv.x *= aspect_ratio;
            FragPos = normalize(vec3(uv, -1.0)) * 1e12;
        }

        vec3 light_dir = light.FragmentToLightDir;
        // TODO use actual light direction
        light_dir = (get_modelview_matrix() * vec4(1.0, 0.0, 0.0, 0.0F)).xyz;

        float lightPower = 30.0;
        vec3 cDir = FragPos;
        // TODO use atmosphere settings for this scattering function as well
        color.rgb = calculate_scattering(
        vec3(0.0),
        normalize(cDir),
        length(cDir),
        get_modelview_matrix(),
        color.rgb,
        normalize(light_dir),
        vec3(lightPower));

        if (CloudLighting){
            color.rgb = mix(color.rgb, vec3(1.0F), Diffuse.r);
        }
    }
}
